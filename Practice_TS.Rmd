---
title: "Time Series"
author: "Akash Mittal"
date: "2025-08-12"
output: html_document
---

```{r}
# terminal commands to push to github 
# git remote add origin https://github.com/sky-akash/Time-Series.git
# git push -u origin master

# want to know what changed between committs ?
# git log c5e3719..3c5a3e8
# git log --oneline c5e3719..3c5a3e8
# ? what changed from commit A (c5e3719) to commit B (3c5a3e8).

```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
# ye naam kyun dena ?
#  Naam dene ke 5 faayde:
# 1. Error messages ko samajhne mein aasani hoti hai
# 2. Document ke structure ko samajhna easy ho jaata hai
# 3. Caching ke liye zaroori hota hai
#     {r clean-data, cache=TRUE}
# 4. Output files (like images) ka naam control karna
#     {r scatter-plot}
#     plot(cars)
#     O/p Name will be : scatter-plot-1.png
# 5. Cross-referencing ke liye
#     “See analysis in chunk model-fit”
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
# Code ko output document mein nahi dikhana, lekin output (jaise plot) ko dikhana.
# 
# In simple terms:
# Code chalega ✔️
# 
# Code output aayega ✔️
# 
# Code khud nahi dikhega ❌

#plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

______________________________________________________________________________________________________________________

```{r}
#install.packages("fpp3", dependencies = TRUE)

library(fpp3)         # Loads a collection of packages (including tsibble, fable, feasts) for forecasting and time series analysis.

library(fable)        # Used for forecasting models (like ARIMA, ETS, etc.) with tidy syntax.

library(tibble)       # A modern reimagining of data frames that is more consistent and user-friendly.

library(tsibble)      # Provides a time-aware data structure (tsibble) for tidy time series analysis.

library(feasts)       # Tools for time series feature extraction and decomposition (like STL, ACF, etc.).

library(tsibbledata)  # Provides sample time series datasets (such as `aus_retail`, `global_economy`, etc.).

library(tidyr)        # Helps in tidying data (reshaping, pivoting, separating columns, etc.).

library(ggplot2)      # A popular and flexible system for data visualization using the grammar of graphics.

library(lubridate)    # Makes working with dates and times easier (e.g., parsing, extracting components like year/month).

library(dplyr)        # Used for data manipulation (filtering, selecting, mutating, summarizing, etc.).

library(fabletools)   # Provides tools and infrastructure to support modeling with fable (under the hood utilities).


```

## Time Series Graphics

```{r avialable datasets}

data() # lists abvailable datasets (A lot of them in these packages....)

```


```{r aus_retail dataset}

# summary(aus_retail)
str(aus_retail)

```



```{r unique-items}

# aus_retail |> distinct('Series ID')
# 
# aus_retail |> unique('State') # issue as unique wants a vector, and can't evven do aus_retail$'State' as It makes me pass df again to original df

aus_retail |> 
  pull(State) |>
  unique()

# OR 

unique(pull(aus_retail, State))

# OR 

unique(aus_retail$State)      

# OR Use distinct from (deplyr)

aus_retail |> distinct(State) |> pull()             # All aboe ancd this doens give output as tibble but just "A VECTOR"

aus_retail |> distinct(State) # here even output is a tibble

# ###########

aus_retail |> distinct(`Series ID`)
aus_retail |> distinct(State)
aus_retail |> distinct(Industry)

colnames(aus_retail)
head(aus_retail)


aus_retail |> distinct(State, Industry) # distinct also used to in combined series too

```


```{r}

aus_retail |>
  filter(`Series ID` == 'A3349640L') |>
  autoplot(Turnover)

```


```{r}
aus_retail |> 
  filter(`Series ID` == "A3349640L") |>
  model(ETS(Turnover)) |>
  forecast(h = '2 year')

```




```{r}
aus_retail |> 
  filter(`Series ID` == "A3349640L") |>
  model(ETS(Turnover)) |>
  forecast(h = '2 years')
```




```{r ch1}

y <- tsibble(
  Year = 2015:2019,
  Observation = c(123, 39, 78, 52, 110),
  index = Year
)

plot(y)

y

```

```{r}
# converting a dataset to tsibble

# z = data.frame("Month" = "2019 Jan" to "2019 May", # won't work as need to individually write the month year data
#                "observation" = c(50, 23, 45, 34, 67))

z = data.frame(
  "Month" = seq(yearmonth("2019 Jan"), yearmonth("2019 May"), by = 1),
  "observation" = c(50, 23, 45, 34, 67))


z

z |> 
  mutate(Month = yearmonth(Month)) |>
  as_tsibble(index=Month)
# Not yet assigned back to z, so z will still be a df not a tsibble

z

# Notes on ts data
# 1. Creating or cleaning time columns
# If you have a column like "2019 Jan" or "2020 Q2" in character format, you'll use:
# 
# Frequency	Use this function	Example
# Monthly	yearmonth()	yearmonth("2019 Jan")
# Quarterly	yearquarter()	yearquarter("2020 Q2")
# Weekly	yearweek()	yearweek("2021 W05")
# Daily	ymd() or as_date()	ymd("2021-08-12")
# Hourly+	ymd_hms() or as_datetime()	ymd_hms("2021-08-12 13:45:00")

# 2. Converting to a tsibble
# as_tsibble(index = time_column) # time_column must of class mentioned above or POSIXct

# 3. Creating date sequences
# seq(yearmonth("2019 Jan"), yearmonth("2020 Jan"), by = 1)
# seq(yearquarter("2019 Q1"), yearquarter("2020 Q1"), by = 1)
# seq(ymd("2022-01-01"), ymd("2022-12-31"), by = "1 day")

#### Notice the difference between how by is passed for difference base values of time


```



```{r}
# key variables in time series of tsibble 
# allows multiple time series to be stored in a single object
#

olympic_running


# 312*4 [4Y] - 312 rows, 4 columns and period of 4 years
# key -> length, sex [14] -> means 14 differencet time series are there
# The 14 time series in this object are uniquely identified by the keys: the Length and Sex variables.
#

olympic_running |>
  distinct(Length, Sex)

```


```{r deplyr functions}

# mutate(), filter(), select() and summarise() on tsibble object

PBS

key_vars(PBS)

PBS |>
  filter(ATC1=="A")

PBS |>
  filter(ATC1=="A") |>
  select(Month, Concession, Type)

PBS |>
  filter(ATC1=="A") |>
  select(Month, Concession, Type, Cost) |>
  summarize(TotalC=sum(Cost))


PBS |>
  filter(ATC1 == "A") |>
  select(Month, Concession, Type, Cost) |>
  summarize(TotalC = sum(Cost)) |>
  mutate(Cost = TotalC/1e6)

# saving the tsibble

PBS |>
  filter(ATC2 == "A10") |>
  select(Month, Concession, Type, Cost) |>
  summarise(TotalC = sum(Cost)) |>
  mutate(Cost = TotalC / 1e6) -> a10          # saving the tsibble


a10
```

```{r}
has_gaps(PBS)   # Are there any missing time points? # to check for any missing time series data momtnths etc.
# .gaps = FALSE → No months are missing; the time series is complete.
# .gaps = TRUE → Some months are missing in the time series — there's a gap in the timeline.
############

# if any gaps can fill using """""""""fill_gaps()"""""" or """"""na_interpolate()""""""

############
n_keys(PBS)     # How many unique series?
```


```{r csv_to_tsibble}
#

prison <- readr::read_csv("https://OTexts.com/fpp3/extrafiles/prison_population.csv")

summary(prison)
str(prison)

# spc_tbl_ [3,072 × 6] (S3: spec_tbl_df/tbl_df/tbl/data.frame)
#  $ Date      : Date[1:3072], format: "2005-03-01" "2005-03-01" "2005-03-01" "2005-03-01" ...
#  $ State     : chr [1:3072] "ACT" "ACT" "ACT" "ACT" ...
#  $ Gender    : chr [1:3072] "Female" "Female" "Female" "Female" ...
#  $ Legal     : chr [1:3072] "Remanded" "Remanded" "Sentenced" "Sentenced" ...
#  $ Indigenous: chr [1:3072] "ATSI" "Non-ATSI" "ATSI" "Non-ATSI" ...
#  $ Count     : num [1:3072] 0 2 0 5 7 58 5 101 51 131 ...
#  - attr(*, "spec")=
#   .. cols(
#   ..   Date = col_date(format = ""),
#   ..   State = col_character(),
#   ..   Gender = col_character(),
#   ..   Legal = col_character(),
#   ..   Indigenous = col_character(),
#   ..   Count = col_double()
#   .. )
#  - attr(*, "problems")=<externalptr> 


prison <- prison |>
  mutate(Quarter = yearquarter(Date)) |>
  select(-Date) |>
  as_tsibble(key = c(State, Gender, Legal, Indigenous),
             index = Quarter)
prison


# More complicated (and unusual) seasonal patterns can be specified using the "period()" function in the "lubridate" package.

```

```{r}
ansett
```



```{r Time plots}

melsyd_economy <- ansett |>
  filter(Airports == "MEL-SYD", Class=="Economy")|>
  mutate(Passengers = Passengers/1000)

melsyd_economy

autoplot(melsyd_economy,Passengers) + # dataset and the column data which has to be plotted
  labs(title = "Ansett airlines economy class",
       subtitle = 'Melbourne-Sydney',
       y = "Passengers ('000) i.e. in Thousands")

```

```{r}

a10

str(a10)
#summary(a10)

autoplot(a10, Cost) +
  labs(y = "Million dollars",
       title = "Australian drug Sales")

a10 |> 
  gg_season(Cost, labels = 'both') +
  labs(y = "Millions Dollars",
       title = "Seasonal Plot : Antidiabetic Drug Sales")

# making seasonal plot, so it automatically plotted the lines as per every year and different lines for each month as data is monthly seasonal


```


```{r}
# data which is seasonal by day

vic_elec

str(vic_elec)
# i.e. half hourly data is given

vic_elec |> 
  gg_season(Demand, period = "day")  +           #  If a string (e.g., "1y" for 1 year, "3m" for 3 months,
                                                # "1d" for 1 day, "1h" for 1 hour, "1min" for 1 minute, "1s"
                                                # for 1 second), it's converted to a Period class object from
                                                # the lubridate package. Note that the data must have at least
                                                # one observation per seasonal period, and the period cannot be
                                                # smaller than the observation interval.
  theme(legend.position = "none") + 
  labs(y = "MWh", title = "Electricity Demand : Victoria")



```

```{r}
# seasonal plots

vic_elec

vic_elec |> gg_season(Demand, period = "week") +
  theme(legend.position = "none") +
  labs(y="MWh", title="Electricity demand: Victoria")

vic_elec |> gg_season(Demand, period = "month") +
  labs(y="MWh", title="Electricity demand: Victoria")

vic_elec |> gg_season(Demand, period = "year") +
  labs(y="MWh", title="Electricity demand: Victoria")

```
```{r}

# # vic_elec |> gg_season(Demand, period = "month")
# # Cannot pass series as strings in gg_subseries , it re
# vic_elec |> gg_subseries(Demand, period = 336) +
#   labs(y = "Million dollars",
#        title = "Australian antidiabetic drug sales")

```


Subseries plots

```{r}
a10

str(a10)
```

```{r}
a10 |>
  gg_season(Cost)

```

```{r subseries plots seasonals}

a10 |>
  gg_subseries(Cost) +
  labs(
    y = "$ (millions)",
    title = "Australian antidiabetic drug sales"
  )

```




```{r tourism australian - sub_series vs sub_seasonal plots}

tourism

str(tourism)

# tbl_ts [24,320 × 5] (S3: tbl_ts/tbl_df/tbl/data.frame)
#  $ Quarter: qtr [1:24320] 1998 Q1, 1998 Q2, 1998 Q3, 1998 Q4, 1999 Q1, 1999 Q2, 1999 Q3, 1999 Q4, 2000 Q1, 2000 Q2, ...
#    ..@ fiscal_start: num 1
#  $ Region : chr [1:24320] "Adelaide" "Adelaide" "Adelaide" "Adelaide" ...
#  $ State  : chr [1:24320] "South Australia" "South Australia" "South Australia" "South Australia" ...
#  $ Purpose: chr [1:24320] "Business" "Business" "Business" "Business" ...
#  $ Trips  : num [1:24320] 135 110 166 127 137 ...

# tourism is tsibble data with Quarter as time frames..so while grouping the hierarchy is State -> Region
# grouping by state we get data for 

holidays <- tourism |>
  filter(Purpose == 'Holiday') |>
  group_by(State) |>
  summarise(Trips=sum(Trips))

holidays

autoplot(holidays, Trips)+
  labs(y = "Trips (thousands") +
  labs(title = "Australian domestic holidays")


gg_season(holidays, Trips) +                      # sub seasonal plot ... and there are eight states (as)
  labs(y = "Overnight trips ('000)",
       title = "Australian domestic holidays")

holidays |>                                       
  gg_subseries(Trips) +                           # sub series plots ..... time frame is quarterly, and
                                                  # thus 4 quarters for each state
  labs(y = "Overnight trips ('000)",
       title = "Australian domestic holidays")

```

```{r}
holidays
```


```{r}

vic_elec |>
  filter(year(Time) == 2014) |>
  autoplot(Demand) +
  labs(y = "GW",
       title = "Half-hourly electricity demand: Victoria")

```




```{r}
vic_elec

vic_elec |>
  filter(year(Time) == 2014) |>
  autoplot(Temperature) +
  labs(
    y = "deg C",
    title = "Half Hourly Temperatures (Melbourne)"
  )

# Note: In the dataset, the temperatures are for Melbourne, the largest city in Victoria, while the demand values are for the entire state.

```

```{r}
# scatterplot of series Temp vs demand

vic_elec |>
  filter(year(Time)==2014) |>
  ggplot(aes(x=Temperature, y=Demand)) +
  geom_point() + 
  labs(
    title = "Electricity Demand vs Temp.",
    x = "Temp. deg C Melbourne",
    y = "Electricity  Demand in Victoria"
  )


```

```{r}
# Scatterplot Matrices


visitors <- tourism |>
  group_by(State) |>
  summarise(Trips = sum(Trips))


visitors |>
  ggplot(aes(x = Quarter, y = Trips)) +
  geom_line() +
  facet_grid(vars(State), scales = "free_y") +
  labs(title = "Australian domestic tourism",
       y= "Overnight trips ('000)")


visitors |>
  pivot_wider(values_from=Trips, names_from=State) |>
  GGally::ggpairs(columns = 2:9)

```




```{r}

unique(visitors$State)

```


```{r lag plots}

aus_production 
str(aus_production)
#summary(aus_production) - error isssue with time series

```

```{r}

recent_production <- aus_production |>
  filter(year(Quarter) >= 1990)

recent_production |>
  feasts::gg_lag(Beer, geom = "path", lags = 1:10, arrow=TRUE) +                   # geom can be "point" or "path" # by fefault there are 9 lags 
  labs(x = "lag(Beer, k)")

```


```{r autocorrelations}

recent_production |>
  feasts::ACF(Beer, lag_max = 50)
  

recent_production |>
  feasts::ACF(Beer, lag_max = 50) |>                        # this will give a tsibble df with lags and acf (And autoplot will
                                        # plot it accordingly)
  autoplot() + 
  labs(title = "Australian Beer Production")
  
  

```
* peaks in 4 quarters and troughs too.
* dashed blue line -> if correlations are significantly differente from 0 or not. "Bartlett Bands"

```{r trend and seasonality in ACF}

a10
str(a10)    #  3 monthly seasonal


a10 |>
  feasts::ACF(Cost, lag_max = 50) |>
  autoplot() +
  labs(title="ACT Anti")



```
 <!-- exponentially decreasing acf with peaks at every 12 months apart..better check the PACF plots too.  -->

```{r drawing PACF}
a10 |>
  feasts::PACF(Cost, lag_max = 50) |>
  autoplot() +
  labs(title="ACT Anti")

```


```{r White Noise}
set.seed(3)
y <- tsibble(
  sample = 1:50,
  wn = rnorm(50),
  index = sample
)

y 

y |> autoplot(wn) +
  labs(title = "White Noise", y = "")               # y = "" removes label from y axis


y |>
  ACF(wn) |>
  autoplot() + labs(title="White Noise ACF")


```

## Time Series Decomposition

```{r transformation and adjustment}

global_economy

str(global_economy)

tsibbledata::global_economy |>
  filter(Country == "Australia") |>
  autoplot(GDP/Population) +
  labs(title = "GDP per capita", y="$US")


global_economy

str(global_economy)

tsibbledata::global_economy |>
  filter(Country == "India") |>
  autoplot(GDP/Population) +
  labs(title = "GDP per capita", y="$US")

```


```{r inflation price adjustments}

print_retail <- aus_retail |>
  filter(Industry == "Newspaper and book retailing") |>
  group_by(Industry) |>
  index_by(Year = year(Month)) |>
  summarise(Turnover = sum(Turnover))  # |> mutate(Industry = "Newspaper and book retailing")

print_retail              # newspaper printing turnover data over years
  
aus_economy <- global_economy |>
  filter(Code == "AUS")

aus_economy               # australian economy data oer years including CPI

# both have different years and also we need to mathc data for years so we perform left join to have consistent data

print_retail |>
  left_join(aus_economy, by = "Year") |> 
  mutate(`Inf. Adjusted Turnover` = Turnover/CPI * 100) # |>
  #pivot_longer(c(Turnover, `Inf. Adjusted Turnover`),
   #            values_to = "Turnover")
print_retail

```


```{r}

print_retail |>
  left_join(aus_economy, by = "Year") |> 
  mutate(`Inf. Adjusted Turnover` = Turnover/CPI * 100) |>
  pivot_longer(c(Turnover, `Inf. Adjusted Turnover`), # by long format we create a column with name "name" and values given in this vector, we can remname the coum too, using names_to = `Turnover Type`
              values_to = "Turnover") |>  # turnover is just a name of new column
  mutate(name=factor(name, 
                     levels=c('Turnover', 'Inf. Adjusted Turnover'))) |>
  ggplot(aes(x = Year, y = Turnover)) +
  geom_line() + 
  facet_grid(name ~ ., scales = "free_y") +
  labs(title = "Turnover: Australian print media industry",
       y = "$AU")
  
  
print_retail


```


Box COX Transformation (allows for negative values which log transform doesn't) (also helps in converting data to normal form (not always))
    
      |
      | log(Yt)      if λ = 0  (for log 0, ie. zero remainss zero)
Wt =  | 
      | ((sign(Yt)/Yt)^(λ) - 1) / λ        else
      | OR 
      | (Yt)^(λ) - 1) / λ)                  # variation neeeds to know difference
      
A good value of  λ  is one which makes the size of the seasonal variation about the same across the whole series, as that makes the forecasting model simpler.
      
```{r BoX Cox Transformation & guerrero feature}

# lambda is found using guerrero feature

aus_production |>
  autoplot(Gas)

lambda <- aus_production |>
  fabletools::features(Gas, features = guerrero) |>
  pull(lambda_guerrero)


aus_production |>
  autoplot(box_cox(Gas, lambda)) +
  labs(y = "",
       title = latex2exp::TeX(paste0(
         "Transformed gas production with $\\lambda$ = ",
         round(lambda,2))))



```

```{r Time series components, STL decomposition}

fpp3::us_employment # monthly seasonal with Series_ID as having 148 different series data

us_retail_employment <- us_employment |>
  filter(year(Month) >= 1990, Title == 'Retail Trade') |> # title named coumn with valeus being Retail Trade
  select(-Series_ID)

us_retail_employment

autoplot(us_retail_employment,Employed)+
  labs(y = "Persons (thousands)",
       title = "Total Employment in US Retail")


```
<!-- # looks to have trend and some seasonality maybe ? let's divide into parts and check | -->

```{r decomposition}

dcmp <- us_retail_employment |>
  fabletools::model(
                    stl = STL(Employed)
                    )
fabletools::components(dcmp)

str(components(dcmp))

```

<!-- The output above shows the components of an STL decomposition. -->

```{r}

components(dcmp) |>
  as_tsibble() |>                                                 # components(dcmp) is a dataframe so need to                                                                         # convert to tsibble
  autoplot(Employed, colour="pink") +
  geom_line(aes(y=trend), colour="darkgreen") +
  labs(
    y = "Persons (k)",
    title = "Total Employment in US Retail"
  )

```


```{r}


```


```{r}
```


```{r}
```


```{r}
```




```{r}
# Plot one time series
aus_retail 
# |>
#   filter(`Series ID`=="A3349640L") |>
#   autoplot(Turnover)



```

```{r}

```


```{r}

# Plot one time series
# aus_retail |>
#   filter(`Series ID`=="A3349640L") |>
#   autoplot(Turnover)

aus_retail <- readr::read_csv("https://OTexts.com/fpp3/extrafiles/aus_retail.csv") |>
  mutate(Month = yearmonth(Month)) |>
  as_tsibble(index = Month, key = c(`Series ID`))


```

```{r}

```

